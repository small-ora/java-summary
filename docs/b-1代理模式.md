# 代理模式

## 代理模式分为静态代理和动态代理
- 静态代理使用比较简单,但是只能代理一个固定的类,使用起来不灵活
- 动态代理使用起来比较麻烦,但是用起来很灵活,可以代理所有的类
  - 动态代理有两种实现方式,一种是通过jdk实现动态代理,另一种是使用cglib实现动态代理
  - Jdk实现代理模式: 被代理的类必须要实现一个或多个接口,否则jdk不知道代理的类有哪些方法
  - cglib实现的动态代理则不需要,cglib的原理是把生成的代理类继承被代理类
  
## 静态代理详解
1.首先我们有一个Tank类,类里面有一个接口Movable,Tank类实现了Movable接口,并重写了move方法
```java
public class Tank implements Movable{

	@Override
	public void move() {
		System.out.println("Tank move...");
		try {
    //移动消耗的时间
			Thread.sleep(new Random().nextInt(10000));
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		new Tank().move();
	}
}

interface Movable{
	void move();
}
```
2.现在我们有个需求,我们需要在调用move方法的时候加个日志,方便后续排查问题,最简单的方法就是在调用move方法之前加上一行日志,但是如果后续我们需要加别的信息,又要修改代码去添加,不是很优雅,所以我们自定义一个类,实现Movable接口,并且拥有Movble作为成员变量
```java
class LogProxy implements Movable{

	Movable movable;
	LogProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		System.out.println("tank start move");
		movable.move();
		System.out.println("tank stop move");
	}
}
```
这样我们如果需要在move方法上加日志就很简单了,把main里面调用tank的move方法修改为
```java
new LogProxy(new Tank()).move();
```
是不是很优雅,如果我们还想要统计调用move方法消耗的时间,很简单.我们在定义一个统计运行时间的代理类
```java
class TimeProxy implements Movable{

	Movable movable;
	TimeProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		long start = System.currentTimeMillis();
		movable.move();
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}
```
然后同样的,修改main方法中调用move方法的代码
```java
new TimeProxy(new LogProxy(new Tank())).move();
```
最后,全部的代码如下,这就是静态代理了
```java
public class Tank implements Movable{

	@Override
	public void move() {
		System.out.println("Tank move...");
		try {
			Thread.sleep(new Random().nextInt(10000));
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		new LogProxy(new TimeProxy(new Tank())).move();
	}
}

class TimeProxy implements Movable{

	Movable movable;
	TimeProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		long start = System.currentTimeMillis();
		movable.move();
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}

class LogProxy implements Movable{

	Movable movable;
	LogProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		System.out.println("tank start move");
		movable.move();
		System.out.println("tank stop move");
	}
}

interface Movable{
	void move();
}
```

## 动态代理
> 在网上学习的时候,看到一个博客讲的特别好,可以参考 https://www.cnblogs.com/wyq1995/p/10936286.html
### 使用JDK生成代理对象
还是静态代理的需求,要对tank添加日志和运行时间的打印,这个时候,我们就不需要自己去写代码代理Tank类了,废话不多说,直接上代码
```java
public class DynamicProxy {

	public static void main(String[] args) {
		Tank tank = new Tank();
		//设置系统属性,把动态代理生成的class对象保存下来
		System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
		Movable logMovable = (Movable) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(),
				new Class[]{Movable.class},
				(proxy, method, args1) -> {
					System.out.println("method " + method.getName() + " start..");
					Object invoke = method.invoke(tank, args1);
					System.out.println("method " + method.getName() + " stop..");
					return invoke;
				});
		Movable timeMovable = (Movable) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(),
				new Class[]{Movable.class},
				(proxy, method, args1) -> {
					long start = System.currentTimeMillis();
					Object invoke = method.invoke(logMovable, args1);
					long end = System.currentTimeMillis();
					System.out.println("time: " + (end - start));
					return invoke;
				});
		timeMovable.move();

	}

	static class Tank implements Movable {

		@Override
		public void move() {
			System.out.println("Tank move...");
			try {
				Thread.sleep(new Random().nextInt(10000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	interface Movable {
		void move();
	}
}
```
因为动态代理生成的class我们看不到,不知道怎么实现,不方便理解,所以添加了一个参数,把JDK动态代理生成的class文件保存下来,然后用idea打开,可以看到大致内容,方便理解

JDK动态代理的核心代码就是下面这个方法
```java
public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
```
- 第一个参数是一个ClassLoder对象,可以是任意类的类加载器,通常使用被代理对象的类加载器
- 第二个参数是产生的代理对象要实现的接口数组,这里一般就填写被代理对象实现的接口
- 第三个参数最重要,这个一个接口类型,这个接口里面只有一个invoke方法,我这里使用了Lamda表达式写了这个接口的实现,这个接口的三个参数分别是
```java
public Object invoke(Object proxy, Method method, Object[] args)
```
  - 第一个是生成的代理对象
  - 第二个参数是被代理对象的方法对象
  - 第三个参数是执行方法的参数
- 最后的返回值就是生成的代理对象

我们调用生成的代理对象的move方法,会首先执行我们自己实现的InvocationHandler里面的invoke方法,然后我们在invoke方法中完成自己想要的操作,然后调用被代理对象的方法 ***Object invoke = method.invoke(logMovable, args1);*** 把被代理对象和参数传进去,就会继续调用被代理对象的方法了.
执行方法后我们我看到根目录生成了代理对象的class文件,直接用idea打开,就可以看到类似代码
<details>
<summary>生成的代理对象Class</summary>

```java
 final class $Proxy0 extends Proxy implements Movable {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void move() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m3 = Class.forName("com.test.proxy.DynamicProxy$Movable").getMethod("move");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```
</details>
由Class文件可以看到生成的代理对象继承了Proxy对象,同时实现了Movable接口,在静态代码块里面分别加载了Object对象的方法和Movable的方法,m3是Movable里面的方法
我们再看class里面的move方法,调用了 ***super.h.invoke(this, m3, (Object[])null);*** 调用了父类的h对象的Invoke方法,这个h对象就是我们实现的InvocationHandler对象,这里就很清晰了.为什么会执行我们自定义的Invoke方法

