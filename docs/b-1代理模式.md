# 代理模式

## 代理模式分为静态代理和动态代理
- 静态代理使用比较简单,但是只能代理一个固定的类,使用起来不灵活
- 动态代理使用起来比较麻烦,但是用起来很灵活,可以代理所有的类
  - 动态代理有两种实现方式,一种是通过jdk实现动态代理,另一种是使用cglib实现动态代理
  - Jdk实现代理模式: 被代理的类必须要实现一个接口,否则jdk不知道代理的类有哪些方法
  - cglib实现的动态代理则不需要
  
## 静态代理详解
1.首先我们有一个Tank类,类里面有一个接口Movable,Tank类实现了Movable接口,并重写了move方法
```java
public class Tank implements Movable{

	@Override
	public void move() {
		System.out.println("Tank move...");
		try {
    //移动消耗的时间
			Thread.sleep(new Random().nextInt(10000));
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		new Tank().move();
	}
}

interface Movable{
	void move();
}
```
2.现在我们有个需求,我们需要在调用move方法的时候加个日志,方便后续排查问题,最简单的方法就是在调用move方法之前加上一行日志,但是如果后续我们需要加别的信息,又要修改代码去添加,不是很优雅,所以我们自定义一个类,实现Movable接口,并且拥有Movble作为成员变量
```java
class LogProxy implements Movable{

	Movable movable;
	LogProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		System.out.println("tank start move");
		movable.move();
		System.out.println("tank stop move");
	}
}
```
这样我们如果需要在move方法上加日志就很简单了,把main里面调用tank的move方法修改为
```java
new LogProxy(new Tank()).move();
```
是不是很优雅,如果我们还想要统计调用move方法消耗的时间,很简单.我们在定义一个统计运行时间的代理类
```java
class TimeProxy implements Movable{

	Movable movable;
	TimeProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		long start = System.currentTimeMillis();
		movable.move();
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}
```
然后同样的,修改main方法中调用move方法的代码
```java
new TimeProxy(new LogProxy(new Tank())).move();
```
最后,全部的代码如下,这就是静态代理了
```java
public class Tank implements Movable{

	@Override
	public void move() {
		System.out.println("Tank move...");
		try {
			Thread.sleep(new Random().nextInt(10000));
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		new LogProxy(new TimeProxy(new Tank())).move();
	}
}

class TimeProxy implements Movable{

	Movable movable;
	TimeProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		long start = System.currentTimeMillis();
		movable.move();
		long end = System.currentTimeMillis();
		System.out.println(end-start);
	}
}

class LogProxy implements Movable{

	Movable movable;
	LogProxy(Movable movable){
		this.movable = movable;
	}

	@Override
	public void move() {
		System.out.println("tank start move");
		movable.move();
		System.out.println("tank stop move");
	}
}

interface Movable{
	void move();
}
```
